<!DOCTYPE html>
<html lang="en">

<head>
	<title>The Project | EvSched</title>
	<!-- META -->
	<meta charset="utf-8">
	<meta name="title" content="The Project | EvSched">
	<meta name="description"
		content="EvSched is an evolutionary algorithm to help people schedule their lives in new and effective ways.">
	<meta name="keywords" content="evsched, kronologue, algorithm, scheduling, optimization, evolution, genetic">
	<meta name="author" content="Mrigank Pawagi">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<!-- SOCIAL MEDIA -->
	<meta property="og:type" content="website">
	<meta property="og:url" content="http://evsched.mrigank.pawagi.com/">
	<meta property="og:title"
		content="EvSched | An evolutionary algorithm for optimizing linear schedules in daily life.">
	<meta property="og:description"
		content="EvSched is an evolutionary algorithm to help people schedule their lives in new and effective ways.">
	<meta property="og:image" content="http://evsched.mrigank.pawagi.com/images/banner.png">
	<meta property="twitter:card" content="summary_large_image">
	<meta property="twitter:url" content="http://evsched.mrigank.pawagi.com/">
	<meta property="twitter:title"
		content="EvSched | An evolutionary algorithm for optimizing linear schedules in daily life.">
	<meta property="twitter:description"
		content="EvSched is an evolutionary algorithm to help people schedule their lives in new and effective ways.">
	<meta property="twitter:image" content="http://evsched.mrigank.pawagi.com/images/banner.png">
	<!-- PWA -->
	<link rel="manifest" href="manifest.json">
	<meta name="mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="application-name" content="EvSched">
	<meta name="apple-mobile-web-app-title" content="EvSched">
	<meta name="theme-color" content="#54bbff">
	<meta name="msapplication-navbutton-color" content="#54bbff">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="msapplication-starturl" content="/">
	<link rel="icon" type="image/png" sizes="192x192" href="images/icons/icon-192x192.png">
	<link rel="apple-touch-icon" type="image/png" sizes="192x192" href="images/icons/icon-192x192.png">
	<link rel="icon" type="image/png" sizes="384x384" href="images/icons/icon-384x384.png">
	<link rel="apple-touch-icon" type="image/png" sizes="384x384" href="images/icons/icon-384x384.png">
	<link rel="icon" type="image/png" sizes="512x512" href="images/icons/icon-512x512.png">
	<link rel="apple-touch-icon" type="image/png" sizes="512x512" href="images/icons/icon-512x512.png">
	<link rel="icon" type="image/png" sizes="256x256" href="images/icons/icon-256x256.png">
	<link rel="apple-touch-icon" type="image/png" sizes="256x256" href="images/icons/icon-256x256.png">
	<meta name="msapplication-TileImage" content="images/icons/icon-192x192.png">
	<meta name="msapplication-TileColor" content="#54bbff">
	<!--STYLES-->
	<link rel="stylesheet" href="css/materialize.min.css">
	<link rel="stylesheet" href="css/style.css">
	<link rel="stylesheet" href="css/pages.css">
	<link rel="stylesheet" href="css/project.css">
	<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
	<link
		href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,300;1,400;1,500&display=swap"
		rel="stylesheet">
</head>

<body>
	<div id="loader">
		<div class="preloader-wrapper big active">
			<div class="spinner-layer spinner-blue">
				<div class="circle-clipper left">
					<div class="circle"></div>
				</div>
				<div class="gap-patch">
					<div class="circle"></div>
				</div>
				<div class="circle-clipper right">
					<div class="circle"></div>
				</div>
			</div>
			<div class="spinner-layer spinner-red">
				<div class="circle-clipper left">
					<div class="circle"></div>
				</div>
				<div class="gap-patch">
					<div class="circle"></div>
				</div>
				<div class="circle-clipper right">
					<div class="circle"></div>
				</div>
			</div>
			<div class="spinner-layer spinner-yellow">
				<div class="circle-clipper left">
					<div class="circle"></div>
				</div>
				<div class="gap-patch">
					<div class="circle"></div>
				</div>
				<div class="circle-clipper right">
					<div class="circle"></div>
				</div>
			</div>
			<div class="spinner-layer spinner-green">
				<div class="circle-clipper left">
					<div class="circle"></div>
				</div>
				<div class="gap-patch">
					<div class="circle"></div>
				</div>
				<div class="circle-clipper right">
					<div class="circle"></div>
				</div>
			</div>
		</div>
	</div>
	<nav class="nav-extended"></nav>
	<ul id="slide-out" class="sidenav"></ul>
	<div id="miniHero" style="background-image: linear-gradient(
			109.6deg,
			rgba(62, 161, 219, 1) 11.2%,
			rgba(93, 52, 236, 1) 100.2%
		  );">
		<h1>The Project</h1>
	</div>
	<div class="container">
		<h1 class="center">A Novel Approach to Linear Scheduling using a Genetic Algorithm</h1>
		<hr>
		<blockquote color="yellow">
			<h3>
				This project is under development.
			</h3>
			<p>
				Please note that this article is a draft and is open to suggestions and constructive criticism.
			</p>
		</blockquote>
		<h2>Background</h2>
		<p>Job-scheduling has a wide variety of uses in many industries - the most obvious of which is optimizing
			resources to extract maximum output in minimum time. Such an application has been developed and implemented
			using several algorithms and has proven to be extremely effective in managing multiple parallel tasks - or
			jobs.
		</p>
		<p>
			However, this model cannot be directly adopted for scheduling day-to-day personal activities, particularly
			because of the fact that people - almost always - work linearly, i.e., perform one activity at a time. In
			fact, study has shown that single-tasking is much more productive than multitasking<sup data-cite=0></sup>,
			and can allow people to finish much more work despite taking up tasks in a sequential manner. This not only
			enhances the quality of work, but also minimizes productivity-related distress<sup data-cite=1></sup> for
			students and professionals, among other people.</p>
		<h2>
			Overview
		</h2>
		<p>A large fraction of people<sup data-cite=2></sup> finds it difficult to create a perfect schedule that works
			every single day. All the critical parameters that come into play – urgency, value, physical and mental
			commitment – are too complicated for the human mind to compute accurately, making it difficult for people to
			recognize their exact productivity patterns.</p>
		<p>To provide a mathematically sound solution to this everyday problem, I propose a new approach to linear
			scheduling that is developed specifically to cater to this need. This approach - called <b>EvSched</b> - is
			based on optimization through a genetic algorithm that has been elaborated on in this text.</p>
		<p>I have also developed a prototype called <a href="https://kronologue-ai.web.app">Kronologue</a> to
			demonstrate this technique. Kronologue boils down the process of effective scheduling to a few easy steps
			for the user, whose entire schedule is rearranged and optimized keeping in view their energy and efficiency
			curves, their priorities, their capacities, and their sensitivity to distractions. </p>
		<p>Kronologue has been able to produce schedules with as much as 99% greater productivity<sup
				data-cite=3></sup>.</p>
		<h2>
			Onboarding
		</h2>
		<p>First-time users are asked to provide a set of baseline data in order to begin using the scheduler based on
			EvSched. This data includes details about the user’s intended sleep pattern (including daytime naps) and
			details about their planned tasks for the day. Each task has a set of properties that have been detailed
			below.</p>
		<ol>
			<li><b>Time</b>
				<p>The user is asked if their tasks have a strict timing, in which case they can simply enter
					this exact time interval. If the task has flexible timings, the user is asked for a preferred time
					interval during the day, along with a <i>Time Priority</i> - which measures the extent of
					rescheduling allowed for the task. The Time Priority of a task with strict timings is set as 100%.
				</p>
			</li>
			<li><b>Task Metrics</b>
				<p>
					The user is asked to provide the following four parameters for each task. These parameters are set
					on a scale<sup data-cite=4></sup> from 0 to 100%. They are variable and their values can change
					over time based on the
					responses received from the user.
				<ul>
					<li><i>Mental Activity</i> - Mental effort required for the task.</li>
					<li><i>Physical Activity</i> - Physical effort required for the task.</li>
					<li><i>Urgency</i> - Degree of immediacy associated with the task.</li>
					<li><i>Value</i> - Importance of the task with respect to the user’s short- or long-term goals.</li>
				</ul>
				</p>
			</li>
			<li><b>Optimization Parameters</b>
				<p>These parameters essentially play the role of weights in the core algorithm and are supposed to be
					determined over time by the program. However, the user is also given the option to enter initial
					values<sup data-cite=5></sup> into these parameters when the task is created for the first time.</p>
				<ul>
					<li>Influence of the previous day's performance on the productivity of each task.
					</li>
					<li>Cumulative <i>Tiring Effect</i> caused by each task over time.</li>
					<li><i>Tiring Effect</i> caused each task per unit time (per minute).
					<li>Effect of tiredness on productivity in each task.</li>
					<li>Effect of mental and physical hindrances on productivity in each task.</li>
				</ul>
			</li>
		</ol>
		<h3>
			Sleep
		</h3>
		<p>Sleep is also treated like a task in this algorithm. However, it is processed separately and the typical
			metrics and parameters denote slightly different information in case of sleep. The user is required to enter
			the duration of their night sleep, and the maximum napping time they need over the day along with the
			minimum nap duration. The meanings of all the metrics and parameters in context of sleep have been described
			below.</p>
		<ol>
			<li><b>Task Metrics</b>
				<p>In case of sleep,
				<ul>
					<li>Mental Activity is replaced by <i>Mental Influence</i> which measures how comfortable the sleep
						is.</li>
					<li>Physical Activity is replaced by <i>Physical Influence</i> which measures how rejuvenating the
						sleep is.</li>
					<li>There is no Urgency property.</li>

				</ul>
				</p>
			</li>
			<li><b>Optimization Parameters</b>
				<p>In case of sleep, the Tiring Effect is treated as the <i>Regenerating Effect</i> by giving it
					negative values for related parameters.</p>
			</li>
		</ol>
		<h2>Rationale for Choice of Metrics and Parameters</h2>
		<p>I conducted a detailed survey<sup data-cite=6></sup> of over 57 people to gather data about
		<ol>
			<li>the current methods that people use for scheduling their daily life.</li>
			<li>the success or failure of these methods.</li>
			<li>factors and trends that affect productivity on short-term and long term bases.</li>
		</ol>
		<p>The survey respondents included both children and adults (ages 11 to 46) from different backgrounds, and
			comprised of 56% females and 44% males.</p>
		</p>
		<p>
			As much as 55% people have reported that they often find it difficult to manage their schedule; the most
			important reasons of low productivity are disturbed sleep (22%) and improper prioritization of tasks (86%).
			It could also be seen that although people are engaged in a lot of activity, they hardly use any
			productivity technique in their daily life (only 45% people are aware of these techniques). While I
			initially expected to find a ‘perfect’ time of the day or a ‘perfect’ workplace setting required for higher
			productivity, the survey revealed that even if this ‘perfect’ exists, it is not the same for every
			individual. In fact, even for a given individual, it can vary on different days. Thus, it became clear that
			we must adopt a personalized approach that can take into account daily and hourly variations in
			productivity, which in turn are based out of a variety of factors.
		</p>
		<p>
			Sleep turned out to be a very important factor in productivity<sup data-cite=7></sup> – and thus it has been
			comprehensively taken
			into account by EvSched. Another important feature revealed by the survey was the abrupt transition
			between mental and physical activity in people with reportedly low productivities. Many people found it
			difficult to determine their maximum efficiency at mental or physical activity at any given time of the day,
			ending up exhausting themselves (mentally or physically) before completing all the planned tasks. Moreover,
			the urgency and the
			value of particular tasks often overrode existing plans for many people – leading to sudden breaks in
			productivity. This
			necessitates a method for examining urgency and value well in time, in order to prevent last-minute hassle
			and stress.
		</p>
		<p>

			I studied all the descriptive responses and gathered the factors that could be measured qualitatively and
			quantitatively. Many factors (like weather and eating habits, among others) examined in the survey
			ultimately turned out to be relatively less important for the purpose of scheduling, and were thus not taken
			into account while creating EvSched.
		</p>
		<h2>Preparing the Base</h2>
		<p>
			This algorithm works on a 2-dimensional matrix where one axis contains 1440 rows<sup data-cite=9></sup> to
			represent each minute<sup data-cite=8></sup> of the day, and the other axis contains 11 columns that contain
			all the information about the task occurring at any particular minute. The conversion of data received from
			the user (and from the database) to this Tasks Matrix is done before the optimization begins.
		</p>
		<p>In additional to the parameters discussed before, each row contains an additional property called
			<i>Cumulative Duration</i>. This is a count of the number of minutes spent in the activity <u>up to the
				concerned minute</u>.
			Also, before being optimized, the Schedule contains each task at the time preferred by the user. This
			schedule is later modified during optimization.
		</p>
		<h2>Plots<sup data-cite=10></sup></h2>
		<p>This algorithm can be best visualized through plots created for different aspects of scheduling. A
			<i>Plot</i> in this context is a 1-dimensional Data-series with 1440 elements denoting a specific
			property of each of the 1440 minutes of the day. If <i>plotted</i> on a graph, it will appear in the
			below format. Details about each plot generated by the algorithm have been discussed in the following text.
		</p>
		<img src="images/sampleplot.png" width="400px">
		<blockquote>
			<p>
				A metric that can be seen in several of the below plots is the <i>Previous Day</i> metric. This is a
				measure of
				the productivity of the user at each minute of the day <i>in the past</i>. This too is stored like a
				Plot, but
				is not directly processed like the plots mentioned later.
			</p>
			<p>
				The previous day metric, (\(\rho_{n}\)) is a weighted mean of the productivities at the n<sup>th</sup>
				minute of the day.
			</p>
			<p class="math">
				\(\rho_n = \frac{1}{D} \sum\limits_{k=0}^{D} e^{-\frac{k}{10}} C_k \frac{H_{m,k} + H_{p,k}}{2}\)
			</p>
			<p>
				Here, $D$ is the total number of days for which the user has used the application, $C_k$ is the percent
				completion (0 – 100%) of the task occurring at the n<sup>th</sup> minute (of the k<sup>th</sup> day),
				and $H_{m,k}$ and $H_{p,k}$ are the degrees (0 – 100%) of mental and physical hindrance to the task
				occurring at the n<sup>th</sup> minute (of the k<sup>th</sup> day). $C_k$, $H_{m,k}$ and $H_{p,k}$ are
				collected for all active minutes (i.e., when a task is being performed), and their values are provided
				by users when they click <i>Mark as Done</i> for any task on their schedule on a given day. Note that
				$k$ is
				counted backwards, i.e., $k=0$ for the current day and $k=D$ for the first day of use of application.
			</p>
			<p>It should be noted that in this function, the factor of $e^{-\frac{k}{10}}$ ensures that recent days have
				a greater influence on the value of $\rho_n$ since this function is majorly meant to pick-up short-term
				patterns of users. To avoid over-tracking the user and to reduce complexity, only the composite values
				of the Previous Day Metric are stored (information regarding the number of days for which the
				application was used ($D$), and the number of days since last usage($d$) will be available in the user’s
				profile), rather than intermediate data. Whenever new data is recorded, the old value is updated as
				shown below.</p>
			<p class="math">
				\(\rho_{\text{new}} = \frac{D \frac{\rho_{\text{old}}}{e^d} + C \frac{H_m + H_p}{2}}{D+1}\)
			</p>
			<br>
		</blockquote>
		<h3>
			Mental Plot
		</h3>
		<p>The <i>mental plot</i> tracks the mental productivity of the user throughout the day. This mental
			productivity ($\eta_n$) is calculated for the n<sup>th</sup> minute of the day through the following
			function.</p>
		<p class="math">
			\( \eta_n = A_n \rho_n - B_n e^{C_n \tau_n / 1000} - D_n \Gamma_n\)
		</p>
		<p>
			Here, $A_n$, $B_n$, $C_n$ and $D_n$ are the metrics for previous day, cumulative tiring effect, tiring
			effect per unit time and effect of tiredness. $\tau_n$ is the cumulative duration of the currently occurring
			task, till the n<sup>th</sup> minute, i.e., $\tau_n = n-k$, where k is the minute when the task began.
			$\Gamma_n$ is the cumulative tiredness, and measures the tiredness from all the tasks that happened before
			the n<sup>th</sup> minute. It is a weighted sum of tiredness from previous tasks.
		</p>
		<p class="math">
			\(\Gamma_n = \sum\limits_{j=0}^{N} \frac{F_j}{n - t_j} \)
		</p>
		<p>
			Here, $F_j$ is the tiredness caused by the j<sup>th</sup> task which began at the $t_j$<sup>th</sup> minute.
			The divisor of $n-t_j$ is used to diminish the effect of distant tasks, and weight recent tasks strongly.
			$F_j$ is calculated by the <i>Mental Strain</i> function in the following manner.
		</p>
		<p class="math">
			$F= C∙B∙M∙T$
		</p>
		<p>
			Here, T is the total duration of the task and M is the Mental Activity of that task.
		</p>
		<p>
			$\eta_n$ is calculated in this fashion because of the assumption that productivity is loosely linked to
			particular times of the day, and that this productivity is degraded exponentially as the any task proceeds,
			while also being influenced by exertion since the beginning of the day.
		</p>
		<p>
			The plot is normalized to convert it to the range $[-1,1]$, by the following transformation that is applied
			to each value in the plot.
		</p>
		<p class="math">
			\(\eta_\text{norm} = 2\frac{\eta - \eta_\text{min}}{\eta_\text{max} - \eta_\text{min}} - 1\)
		</p>
		<p>Finally, a Combined Mental Plot ($\Phi$) is created by combining the normalized mental productivity with the
			Mental Activity for each minute. </p>
		<p class="math">
			\(\Phi = \eta_\text{norm} + M\)
		</p>
		<p>The range of values in this plot is thus $[-1,2]$.</p>
		<h3>Physical Plot</h3>
		<p>The physical plot is similar to the mental plot, except that it tracks the physical productivity of the user
			through the day instead of mental productivity. This physical productivity ($\epsilon_n$) is calculated for
			the n<sup>th</sup> minute of the day by the following function.
		</p>
		<p class="math">
			\(\epsilon _n = A_n \rho_n - B_n e^{C_n \tau_n / 1000} - D_n\Gamma_n\)
		</p>
		<p>
			Here, however, the cumulative tiredness, $\Gamma_n$ is based not on mental, but on physical activity. Thus,
			the tiredness, $F_j$ in this function is calculated by the <i>Physical Strain</i> function.
		</p>
		<p class="math">
			\(F= C∙B∙P∙T\)
		</p>
		<p>
			Here, $P$ is the Physical Activity of the task. Like the Mental Plot, the physical plot is also normalized
			and
			used for computing the Combined Physical Plot ($\Psi$).
		</p>
		<p class="math">
			\(\Psi= \epsilon_\text{norm}+P\)
		</p>
		<h3>Profit Plots</h3>
		<p>
			The importance of each task in the schedule is assessed from a combination of urgency, value and activity.
			Tasks with greater urgency and value provide higher <i>‘profit’</i>, or benefit, on completion (in terms of
			mental relaxation, or personal or professional growth). At the same time, the ‘profit’ is also directly
			dependent on the degree of invested mental or physical activity, since grater investment often comes with an
			expectation for greater outputs. The profit for a particular minute, $\sigma$ is calculated in the following
			manner.
		</p>
		<p class="math">
			$\sigma_m = M\frac{U + V}{2}$
		</p>
		<p class="math">
			$\sigma_p = P\frac{U + V}{2}$
		</p>
		<p>
			Here, $\sigma_m$ and $sigma_p$ are mental and physical <i>profits</i> respectively, while $U$ and $V$ are
			the urgency and the value
			of the task occurring at the particular minute. The range of these plots is $[0,1]$.
		</p>
		<h2>Intuition behind plots</h2>
		<p>EvSched is based on the hypothesis<sup data-cite=11></sup> that the key to achieving maximum productivity is
			to complete the
			most valuable tasks during time spans of maximum productivity.
		</p>
		<p>
			Plots offer a very intuitive to visualize this. The mental and the physical plots provide an overview of
			the net productivity at any given minute of the day, while the profit plots indicate the relative
			importance of the task scheduled at that minute. This relation can be realised best by placing these plots
			on the same graph. Consider the example shown below.<sup data-cite=12></sup>
		</p>
		<img src="images/sampleplot-1.png" width="400px">
		<p>
			In this example, it can be seen that the user is underperforming for a significant part of the day, by doing
			high-value
			activities when efficiency is poor. Likewise, high efficiency is being <i>wasted</i> on a lot of low-value
			tasks. The intention of this algorithm is to minimize this gap and find a schedule where these two plots are
			as perfectly synced as possible.
		</p>
		<p>Mathematically, this task can be seen as a <i>minimization problem</i> where our task is to minimize the area
			indicated below.
		</p>
		<img src="images/sampleplot-2.png" width="400px">
		<p>Notice that we do <u>not</u> penalize excess productivity because it does not necessarily indicate a loss in
			the quality
			of work or in the total efficiency for the day.</p>
		<h2>Scoring</h2>
		<p>The intuition discussed above forms the basis of the scoring mechanism in this algorithm. The <i>mental</i>
			score ($\Delta_m$) and the <i>physical</i> score ($\Delta_p$) are calculated in the following manner.</p>
		<p class="math">
			\(
			\Delta_m = \sum\limits_{n=1}^{1440}
			\begin{cases}
			\sigma_{m,n} - \Phi_{n}, & \sigma_{m,n} - \Phi_{n} \geq 0\\
			0, & \sigma_{m,n} - \Phi_{n} < 0 \end{cases} \) </p>
		<p class="math">
			\(\Delta_p = \sum\limits_{n=1}^{1440}
			\begin{cases}
			\sigma_{p,n} - \Phi_{n}, & \sigma_{p,n} - \Phi_{n} \geq 0\\
			0, & \sigma_{p,n} - \Phi_{n} < 0 \end{cases} \) </p>
		<p>
			The subscript $n$ indicates that the value of the parameter is considered at the
			n<sup>th</sup> minute. The application of these scores is in the optimization function which
			has been explained in the next section. It should be noted that a better schedule is one
			with lower mental and physical scores. Since these scores are representative of the the area
			shown in the previous graph, we are required to minimize them for in order to obtain a
			better schedule.
		</p>
		<h2>The Blockerize Function</h2>
		<p>Before a given schedule is optimized by the algorithm, the Tasks Matrix for the schedule is
			broken down into <i>blocks</i>, where each block is a segment of the Tasks Matrix that
			contains information about a particular task only.</p>
		<img src="images/blockerize.png" width="400px">
		<p>
			Apart from slicing, the blockerize function
		</p>
		<ol>
			<li>separates out the blocks for sleep and for activities with a 100% time priority.</li>
			<li>removes empty blocks (without any activity).</li>
		</ol>
		<p>
			The original time durations of all the activities are preserved in this process.
			<i>Blockerization</i> makes it easy to move around and rearrange activities based on their
			durations and other parameters.
		</p>
		<h2><i>Random</i> Shuffling and Rearranging</h2>
		<p>Before anything else, tasks with strict timings are fixed in the schedule (i.e., a
			<u>new</u> Tasks Matrix), and the durations of <i>gaps</i> (in minutes) between them are
			recorded
			for future
			reference.
		</p>
		<p>For each gap between these fixed tasks, a property called <i>shift-likely</i> ($\omega$) is
			calculated. This is a measure of the degree to which a shift in the timing of the task is
			tolerated. For any i<sup>th</sup> activity, it is calculated in the following manner.</p>
		<p class="math">
			$\omega_i=\mu∙|t_g-t_i |∙\alpha$
		</p>
		<p>
			Here, $\mu$ is the Time Priority of the task and \alpha is a random real number in the range
			$(0,1)$. $t_g$ and $t_i$ are the minutes of beginning of the gap (in the new Tasks Matrix)
			and the beginning of the task (in the original Tasks Matrix) respectively. Their absolute
			difference thus indicates the magnitude of change that will take place if the task is placed
			in this gap.
		</p>
		<p>
			The blocks of all the flexible tasks are arranged in decreasing order of their $\omega$
			values. In this order, it is checked if each task can fit into a particular gap (i.e., if
			the task's duration $A$, is less than or equal to $k$, the length of the gap). The first
			task, in this order, to fit this condition is placed in the new Tasks Matrix at the location
			of the gap.
		</p>
		<p>
			While placing any task in any gap, the task is placed towards the end of the gap (i.e., the
			end of the task coincides with the end of the gap). The duration of the task may also be
			extended into the remaining gap, by an amount $\beta$.
		</p>
		<p class="math">
			$A^\prime=A+\beta$
		</p>
		<p>
			$\beta$ is a random integer in the range $[0,k-A]$ and thus, the duration of the gap is
			reduced from $k$ to $k-A-\beta$ ($\geq0$).
		</p>
		<p>
			This procedure is continued until all the tasks find a place in the new Tasks Matrix.
		</p>
		<h2>Managing Sleep</h2>
		<p>Night’s sleep is divided into two segments: the night part (before midnight) and the morning
			part (after midnight). Both of these are kept fixed but their duration is randomly extended
			into the time before and after the sleep (if any gap exists therein) through the following
			function.</p>
		<p class="math">
			$A_S^\prime=k∙\mu_S∙\alpha$
		</p>
		<p>
			$A_S^\prime$ is the extra sleep time added before or after sleep. Here, $k$ is the idle time
			available before or after sleep, $mu_S$ is the time priority of sleep and $\alpha$ is a
			random real number in the range $(0,1)$. It should be noted that the result of this
			computation is always smaller than k.
		</p>
		<p>
			Naps are treated like blocks. After all <i>other</i> task blocks have been arranged, naps
			are placed in the remaining gaps with durations that are multiples of the minimum nap time,
			depending on the length of the gap. It is reasonable to state that naps are thus
			<i>quantized</i>.
		</p>
		<h2>
			Genetics
		</h2>
		<p>
			Once the new Tasks Matrix is been assembled, the matrix is pre-processed (during which cumulative durations of every task are entered) and then evaluated. 
		</p>
		<p>After the score functions create necessary plots and provide the Mental and the Physical scores, the sum of these scores, ($\Delta_m + \Delta_p$) is compared to the sum of these scores for the Original Tasks Matrix (which are preserved during the process).</p>
		<p>If the new matrix has a better (i.e., lower) score than the original matrix, it is stored as the <i>best schedule</i> and is now used as the original Tasks Matrix for the next iteration. This means that blockerization is now performed on this matrix and the whole process is repeated in the same manner. </p>
		<p>
			If the new score is not better (i.e., it is higher), the new matrix is ignored and the entire process is repeated with the same matrix. One iteration of this process is referred to as a <i>Loop</i>.</p>
		<h2>Variation</h2>
		<p>The variation in the schedule is introduced by an element of randomness while rearranging and extending tasks (and sleep). This variation is random, and is comparable to genetic mutations that occur in any population during duplication. These variations ensure that repeated rearrangements of even the same original matrix will generate unique new matrices.</p>
		<h2>Selection</h2>
		<p>
			Variations are natural, but only the fittest variations survive and propagate. The measure of fitness in this case is the composite score of each schedule (i.e., each Tasks Matrix). The schedules with better scores are retained and others are discarded. 
		</p>
		<h2>Evolution</h2>
		<p>As this process is repeated over multiple generations (i.e., Loops) the best schedules become the basis for other schedules and thus drive evolution towards more efficient schedules.</p>
		<p>
			Once a desired level of optimization has is achieved, the process can be terminated and the best schedule can be provided back to the user.</p>
		<h2>Results</h2>
		<p>For typical schedules, this algorithm has provided highly promising results.
</p><p>
			On average, 50 Loops (which execute in approximately 20 seconds on a 3.6 GHz processor) can improve schedules by as much as 99% (i.e., the composite score has been observed to decrease by 99% at the end of 50 Loops in several test cases). Below is a typical example.
			</p>
			<img src="images/result.png" width="400px">
			<p>While in the above example a sufficiently low score is achieved within just 12 loops, in several instances, this may happen after 35 to 45 loops. As evolution continues, lower scores become increasingly difficult to attain and the schedule becomes practically constant.</p>
			<h2>Growth over time</h2>
			<p>Features like the previous day metric are designed to allow the algorithm to learn more and more about the user over time. By remembering their general long-term and short-term patterns, the algorithm can continue to become more relevant, accurate and personalized over time - while respecting and ensuring user privacy.
			</p>
			<h2>About Kronologue</h2>
			<p>Kronologue is a prototype which employs an intuitive interface alongside EvSched to optimize daily schedules for users. Kronologue's backend has been written in Python and includes almost<sup data-cite=13></sup> all the features that have been discussed in this text. The application is currently available as a Web App, but can be directly packaged to desktop and mobile operating systems as well.
				</p>
			<hr>
		<h2>Footnotes and Citations</h2>
		<ol id="citations"></ol>
	</div>

	<footer class="page-footer"></footer>
	<!--SCRIPTS-->
	<script src="js/jquery.min.js"></script>
	<script src="js/materialize.min.js"></script>
	<script src="js/project.js"></script>
	<script src="js/script.js"></script>
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script type="text/javascript" id="MathJax-script" async
		src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
		</script>
</body>

</html>